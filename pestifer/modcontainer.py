# Author: Cameron F. Abrams <cfa22@drexel.edu>.
""" A namespace object for containing all mods
"""
from argparse import Namespace
from .util import inspect_classes
from .mods import ModTypes
import logging
logger=logging.getLogger(__name__)
class ModContainer(Namespace):
    """A class for collecting all mods into a single, organized object 
    
    Class Attributes
    ----------------
    mod_classes (dict):
        class-name:class-object from pestifer.mods for single mods
    modlist_classes (dict): 
        class-name:class-object from pestifer.mods for lists of mods
    """
    mod_classes,modlist_classes=inspect_classes('pestifer.mods',key='List')
    def __init__(self,input_specs={},**kwargs):
        """ 
        Arguments
        ---------
        input_specs: dict
          dictionary of all mod entries (an entry can be used to initialize a mod class instance); these typically come from a user config file rather than a PDB repository file
        kwargs: dict
          already-parsed modlists, typically generated by the PDB parser
         """
        # for each modtype, make a dictionary keyed on modtype+'s' with value the 
        # modtype Namespace in kwargs or, if not present, a blank Namespace
        prep_dict={f'{a}s':kwargs.get(a,Namespace()) for a in ModTypes}
        # logger.debug(f'modcontainer prepdict {prep_dict}')
        # prep_dict['modclasses']=mod_classes
        if input_specs:
            # we are parsing yaml input directly from yaml config file
            for name,Cls in self.mod_classes.items():
                modcat=f'{Cls.modtype}s'
                if Cls.yaml_header in input_specs: # is this mod in the input?
                    # identify the mod's list class
                    LCls=self.modlist_classes.get(f'{name}List',list)
                    # this mod might already have elements
                    if not hasattr(prep_dict[modcat],Cls.yaml_header):
                        prep_dict[modcat].__dict__[Cls.yaml_header]=LCls([])
                    for entry in input_specs[Cls.yaml_header]:
                        assert type(entry) in [str,dict]
                        prep_dict[modcat].__dict__[Cls.yaml_header].append(Cls(entry))
                else:
                    logger.debug(f'No mods for {Cls.yaml_header} found in user input.')
        # already parsed mods can be incorporated
        for yaml_name,parsed_modlist in kwargs.items():
            modtype=[Cls.modtype for name,Cls in self.mod_classes.items() if Cls.yaml_header==yaml_name][0]
            LCls=self.modlist_classes.get(f'{name}List',list)
            if not hasattr(prep_dict[modtype],yaml_name):
                prep_dict[modtype].__dict__[yaml_name]=LCls([])
            prep_dict[modtype].__dict__[yaml_name].extend(parsed_modlist)
        super().__init__(**prep_dict) 
        logger.debug(f'modcontainer dict {self.__dict__}')
    
    def yield_modlists_bycat(self,cat):
        for key,ls in self.__dict__[cat].__dict__.items():
            yield key,ls